package: org.robovm.apple.avfoundation
include: [foundation.yaml, dispatch.yaml, coreanimation.yaml, corefoundation.yaml, coregraphics.yaml, coreaudio.yaml, coremedia.yaml, corevideo.yaml, audiotoolbox.yaml, mediatoolbox.yaml ]
library: AVFoundation
framework: AVFoundation
clang_args: ['-x', 'objective-c']
headers:
    - /System/Library/Frameworks/AVFoundation.framework/Headers/AVFoundation.h
    - /System/Library/Frameworks/AVFoundation.framework/Headers/AVBase.h
typedefs:
    'void (^)(CMSampleBufferRef, NSError *)': '@Block VoidBlock2<CMSampleBuffer, NSError>'
    'void (^)(CMTime)': '@Block VoidBlock1<CMTime>'
    
enums:
    AVAssetReferenceRestrictions: { first: AVAssetReferenceRestrictionForbidNone, marshaler: ValuedEnum.AsMachineSizedUIntMarshaler }
    AVAssetExportSessionStatus: { first: AVAssetExportSessionStatusUnknown }
    AVAssetImageGeneratorResult: { first: AVAssetImageGeneratorSucceeded }
    AVAssetReaderStatus: { first: AVAssetReaderStatusUnknown }
    AVAssetWriterStatus: { first: AVAssetWriterStatusUnknown }
    AVAudioUnitReverbPreset: {}
    AVAudioUnitEQFilterType: {}
    AVAudioUnitDistortionPreset: {}
    AVAudio3DMixingRenderingAlgorithm: {}
    AVAudioEnvironmentDistanceAttenuationModel: {}
    AVAudioCommonFormat: {}
    AVKeyValueStatus: { first: AVKeyValueStatusUnknown }
    AVAudioPlayerNodeBufferOptions: {}
    AVAudioSessionInterruptionOptions: { prefix: AVAudioSessionInterruptionOption, marshaler: ValuedEnum.AsMachineSizedUIntMarshaler }
    AVAudioSessionSetActiveOptions: { prefix: AVAudioSessionSetActiveOption, marshaler: ValuedEnum.AsMachineSizedUIntMarshaler }
    AVAudioSessionPortOverride: { marshaler: ValuedEnum.AsMachineSizedUIntMarshaler }
    AVAudioSessionRouteChangeReason: { marshaler: ValuedEnum.AsMachineSizedUIntMarshaler }
    AVAudioSessionCategoryOptions: { marshaler: ValuedEnum.AsMachineSizedUIntMarshaler }
    AVAudioSessionInterruptionType: { marshaler: ValuedEnum.AsMachineSizedUIntMarshaler }
    AVAudioSessionErrorCode: {}
    AVAudioSessionInterruptionFlag: { first: AVAudioSessionInterruptionFlags_ShouldResume, prefix: AVAudioSessionInterruptionFlags_, bits: true, marshaler: Bits.AsMachineSizedIntMarshaler }
    AVAudioSessionRecordPermission: {}
    AVAudioSessionSetActiveFlag: { first: AVAudioSessionSetActiveFlags_NotifyOthersOnDeactivation, prefix: AVAudioSessionSetActiveFlags_, bits: true, marshaler: Bits.AsMachineSizedIntMarshaler }
    AVAudioSessionSilenceSecondaryAudioHintType: {}
    AVAudioQuality: { first: AVAudioQualityMin }
    AVCaptureDevicePosition: {}
    AVCaptureFlashMode: {}
    AVCaptureTorchMode: {}
    AVCaptureFocusMode: {}
    AVCaptureAutoFocusRangeRestriction: {}
    AVCaptureAutoFocusSystem: {}
    AVCaptureExposureMode: {}
    AVCaptureWhiteBalanceMode: {}
    AVAuthorizationStatus: {}
    AVCaptureDeviceTransportControlsPlaybackMode: {}
    AVCaptureVideoOrientation: {}
    AVCaptureVideoStabilizationMode: {}
    AVVideoFieldMode: {}
    AVErrorCode: { first: AVErrorUnknown, prefix: AVError, marshaler: ValuedEnum.AsMachineSizedSIntMarshaler }
    AVPlayerStatus: { first: AVPlayerStatusUnknown }
    AVPlayerActionAtItemEnd: { first: AVPlayerActionAtItemEndAdvance }
    AVPlayerItemStatus: { first: AVPlayerItemStatusUnknown }
    AVQueuedSampleBufferRenderingStatus: {}
    AVSampleBufferDisplayLayerQueueManagement: {}
    AVSpeechBoundary: {}
    
categories:
    NSValueAVFoundationExtensions: # DONE
        methods:
            '+valueWith.*':
                name: create
    AVTimeCoding: # DONE
        methods:
            '-encodeCMTime:forKey:':
                trim_after_first_colon: true
            '-decodeCMTimeForKey:':
                name: decodeCMTime
            '-encodeCMTimeRange:forKey:':
                trim_after_first_colon: true
            '-decodeCMTimeRangeForKey:':
                name: decodeCMTimeRange
            '-encodeCMTimeMapping:forKey:':
                trim_after_first_colon: true
            '-decodeCMTimeMappingForKey:':
                name: decodeCMTimeMapping
classes:
    AVFoundation:
        annotations: ['@Marshaler(NSString.AsStringMarshaler.class)']

    AVAsset: # DONE
        properties:
            'tracks':
                type: "NSArray<AVAssetTrack>"
            'trackGroups':
                type: "NSArray<AVAssetTrackGroup>"
            'commonMetadata':
                type: "NSArray<AVMetadataItem>"
            'availableMetadataFormats':
                type: "NSArray<NSString>"
            'availableChapterLocales':
                type: "NSArray<NSLocale>"
            'availableMediaCharacteristicsWithMediaSelectionOptions':
                name: "availableMediaCharacteristics"
                type: "NSArray<NSString>"
        methods:
            '+assetWithURL:':
                name: "create"
                return_type: "AVAsset"
            '-trackWithTrackID:':
                name: "getTrack"
            '-tracksWithMediaType:':
                name: "getTracksWithType"
                return_type: "NSArray<AVAssetTrack>"
            '-tracksWithMediaCharacteristic:':
                name: "getTracksWithCharacteristic"
                return_type: "NSArray<AVAssetTrack>"
            '-metadataForFormat:':
                name: "getMetadata"
                return_type: "NSArray<AVMetadataItem>"
            '-chapterMetadataGroupsWithTitleLocale:containingItemsWithCommonKeys:':
                name: "getChapterMetadataGroups"
                return_type: "NSArray<AVTimedMetadataGroup>"
                parameters:
                    commonKeys:
                        type: "NSArray<AVMetadataItem>"
            '-chapterMetadataGroupsBestMatchingPreferredLanguages:':
                name: "getChapterMetadataGroups"
                return_type: "NSArray<AVTimedMetadataGroup>"
                parameters:
                    preferredLanguages:
                        type: "NSArray<NSString>"
            '-mediaSelectionGroupForMediaCharacteristic:':
                name: "getMediaSelectionGroup"
            '-unusedTrackID':
                property: true
            '-statusOfValueForKey:error:':
                name: "getStatusOfValue"
    AVAssetExportSession: # DONE
        properties:
            'outputFileType':
                type: "NSString"
            'supportedFileTypes':
                type: "NSArray<NSString>"
            'metadata':
                type: "NSArray<AVMetadataItem>"
        methods:
            '-initWithAsset:presetName:':
                name: "init"
            '-determineCompatibleFileTypesWithCompletionHandler:':
                name: "determineCompatibleFileTypes"
                parameters:
                    handler:
                        type: "@Block VoidBlock1<NSArray<NSString>>"
            '-exportAsynchronouslyWithCompletionHandler:':
                name: "exportAsynchronously"
            '+allExportPresets':
                property: true
                return_type: "NSArray<NSString>"
            '+exportPresetsCompatibleWithAsset:':
                name: "getCompatibleExportPresets"
                return_type: "NSArray<NSString>"
            '+determineCompatibilityOfExportPreset:withAsset:outputFileType:completionHandler:':
                name: "determineCompatibilityOfExportPreset"
            '+exportSessionWithAsset:presetName:':
                name: "getExportSession"  
    AVAssetImageGenerator: # DONE
        methods:
            '-initWithAsset:':
                name: "init"
            '-copyCGImageAtTime:actualTime:error:':
                name: "copyCGImage"
            '-generateCGImagesAsynchronouslyForTimes:completionHandler:':
                name: "generateCGImagesAsynchronously"
                parameters:
                    requestedTimes:
                        type: "NSArray<NSValue>"
                    handler: 
                        type: "@Block VoidBlock5<CMTime, CGImage, CMTime, AVAssetImageGeneratorResult, NSError>"
            '+assetImageGeneratorWithAsset:':
                name: "create"
    AVAssetReader: # DONE
        properties:
            'outputs':
                type: "NSArray<AVAssetReaderOutput>"
        methods:
            '-initWithAsset:error:':
                name: "init"
            '-canAddOutput:':
                trim_after_first_colon: true
            '-addOutput:':
                trim_after_first_colon: true
            '+assetReaderWithAsset:error:':
                name: "create"  
    AVAssetReaderAudioMixOutput: # DONE
        properties:
            'audioTracks':
                type: "NSArray<AVAssetTrack>"
            'audioSettings':
                type: "NSDictionary<NSString, ?>"
        methods:
            '-initWithAudioTracks:audioSettings:':
                name: "init"
                parameters:
                    audioTracks:
                        type: "NSArray<AVAssetTrack>"
                    audioSettings:
                        type: "NSDictionary<NSString, ?>"
            '+assetReaderAudioMixOutputWithAudioTracks:audioSettings:':
                name: "create"
                parameters:
                    audioTracks:
                        type: "NSArray<AVAssetTrack>"
                    audioSettings:
                        type: "NSDictionary<NSString, ?>"
    AVAssetReaderOutput: {} # DONE
    AVAssetReaderTrackOutput: # DONE
        properties:
            'outputSettings':
                type: "NSDictionary<NSString, ?>"
        methods:
            '-initWithTrack:outputSettings:':
                name: "init"
                parameters:
                    outputSettings:
                        type: "NSDictionary<NSString, ?>"
            '+assetReaderTrackOutputWithTrack:outputSettings:':
                name: "create"
                parameters:
                    outputSettings:
                        type: "NSDictionary<NSString, ?>" 
    AVAssetReaderVideoCompositionOutput: # DONE
        properties:
            'videoTracks':
                type: "NSArray<AVAssetTrack>"
            'videoSettings':
                type: "NSDictionary<NSString, ?>"
        methods:
            '-initWithVideoTracks:videoSettings:':
                name: "init"
                parameters:
                    videoTracks:
                        type: "NSArray<AVAssetTrack>"
                    videoSettings:
                        type: "NSDictionary<NSString, ?>"
            '+assetReaderVideoCompositionOutputWithVideoTracks:videoSettings:':
                name: "create"
                parameters:
                    videoTracks:
                        type: "NSArray<AVAssetTrack>"
                    videoSettings:
                        type: "NSDictionary<NSString, ?>"
    AVAssetResourceLoader: # DONE
        methods:
            '-setDelegate:queue:':
                trim_after_first_colon: true
    AVAssetResourceLoadingContentInformationRequest: {} # DONE
    AVAssetResourceLoadingDataRequest: # DONE
        methods:
            '-respondWithData:':
                trim_after_first_colon: true
    AVAssetResourceLoadingRequest: # DONE
        methods:
            '-finishLoadingWithError:':
                name: "finishLoading"
            '-streamingContentKeyRequestDataForApp:contentIdentifier:options:error:':
                name: "getStreamingContentKeyRequestData"
                parameters:
                    options:
                        type: "NSDictionary<NSString, ?>"
            '-finishLoadingWithResponse:data:redirect:':
                name: "finishLoading" 
    AVAssetResourceRenewalRequest: {}
    AVAssetTrack: # DONE
        properties:
            'formatDescriptions':
                type: "NSArray<?>" # CMFormatDescription
            'segments':
                type: "NSArray<AVAssetTrackSegment>"
            'commonMetadata':
                type: "NSArray<AVMetadataItem>"
            'availableMetadataFormats':
                type: "NSArray<NSString>"
            'availableTrackAssociationTypes':
                type: "NSArray<NSString>"
        methods:
            '-hasMediaCharacteristic:':
                trim_after_first_colon: true
            '-segmentForTrackTime:':
                name: "getSegment"
            '-samplePresentationTimeForTrackTime:':
                name: "getSamplePresentationTime"
            '-metadataForFormat:':
                name: "getMetadata"
                return_type: "NSArray<AVMetadataItem>"
            '-associatedTracksOfType:':
                name: "getAssociatedTracks"
                return_type: "NSArray<AVAssetTrack>"
    AVAssetTrackGroup: # DONE
        properties:
            'trackIDs':
                type: "NSArray<NSNumber>"
    AVAssetTrackSegment: {} # DONE
    AVAssetWriter: # DONE
        properties:
            'availableMediaTypes':
                type: "NSArray<NSString>"
            'metadata':
                type: "NSArray<AVMetadataItem>"
            'inputs':
                type: "NSArray<AVAssetWriterInput>"
            'inputGroups':
                type: "NSArray<AVAssetWriterInputGroup>"
        methods:
            '-initWithURL:fileType:error:':
                name: "init"
            '-canApplyOutputSettings:forMediaType:':
                trim_after_first_colon: true
                parameters:
                    outputSettings:
                        type: "NSDictionary<NSString, ?>"
            '-canAddInput:':
                trim_after_first_colon: true
            '-addInput:':
                trim_after_first_colon: true
            '-startSessionAtSourceTime:':
                name: "startSession"
            '-endSessionAtSourceTime:':
                name: "endSession"
            '-finishWritingWithCompletionHandler:':
                name: "finishWriting"
            '+assetWriterWithURL:fileType:error:':
                name: "create"
            '-canAddInputGroup:':
                trim_after_first_colon: true
            '-addInputGroup:':
                trim_after_first_colon: true
    AVAssetWriterInput: # DONE
        properties:
            'outputSettings':
                type: "NSDictionary<NSString, ?>"
            'metadata':
                type: "NSArray<AVMetadataItem>"
        methods:
            '-initWithMediaType:outputSettings:':
                name: "init"
                parameters:
                    outputSettings:
                        type: "NSDictionary<NSString, ?>"
            '-initWithMediaType:outputSettings:sourceFormatHint:':
                name: "init"
                parameters:
                    outputSettings:
                        type: "NSDictionary<NSString, ?>"
            '-requestMediaDataWhenReadyOnQueue:usingBlock:':
                name: "requestMediaDataWhenReady"
            '-appendSampleBuffer:':
                trim_after_first_colon: true
            '+assetWriterInputWithMediaType:outputSettings:':
                name: "create"
                parameters:
                    outputSettings:
                        type: "NSDictionary<NSString, ?>"
            '+assetWriterInputWithMediaType:outputSettings:sourceFormatHint:':
                name: "create"
                parameters:
                    outputSettings:
                        type: "NSDictionary<NSString, ?>"
            '-canAddTrackAssociationWithTrackOfInput:type:':
                name: "canAddTrackAssociation"
            '-addTrackAssociationWithTrackOfInput:type:':
                name: "addTrackAssociation"   
    AVAssetWriterInputGroup: # DONE
        properties:
            'inputs':
                type: "NSArray<AVAssetWriterInput>"
        methods:
            '-initWithInputs:defaultInput:':
                name: "init"
                parameters:
                    inputs:
                        type: "NSArray<AVAssetWriterInput>"
            '+assetWriterInputGroupWithInputs:defaultInput:':
                name: "create"
                parameters:
                    inputs:
                        type: "NSArray<AVAssetWriterInput>"
    AVAssetWriterInputPassDescription: {}
    AVAssetWriterInputPixelBufferAdaptor: # DONE
        properties:
            'sourcePixelBufferAttributes':
                type: "NSDictionary<NSString, ?>"
        methods:
            '-initWithAssetWriterInput:sourcePixelBufferAttributes:':
                name: "init"
                parameters:
                    sourcePixelBufferAttributes:
                        type: "NSDictionary<NSString, ?>"
            '-appendPixelBuffer:withPresentationTime:':
                name: "appendPixelBuffer"
            '+assetWriterInputPixelBufferAdaptorWithAssetWriterInput:sourcePixelBufferAttributes:':
                name: "create"
                parameters:
                    sourcePixelBufferAttributes:
                        type: "NSDictionary<NSString, ?>"
    AVAsynchronousVideoCompositionRequest: # DONE
        properties:
            'sourceTrackIDs':
                type: "NSArray<NSString>"
        methods:
            '-sourceFrameByTrackID:':
                name: "getSourceFrame"
            '-finishWithComposedVideoFrame:':
                name: "finish"
            '-finishWithError:':
                name: "finish"
    AVAudioMix: # DONE
        properties:
            'inputParameters':
                type: "NSArray<AVAudioMixInputParameters>"
    AVAudioMixInputParameters: # DONE
        methods:
            '-getVolumeRampForTime:startVolume:endVolume:timeRange:':
                name: "getVolumeRamp"   
    AVAudioPlayer: # DONE
        properties:
            'settings':
                type: "NSDictionary<NSString, ?>"
            'channelAssignments':
                type: "NSArray<AVAudioSessionChannelDescription>"
        methods:
            '-init.*':
                name: "init"
            '-playAtTime:':
                trim_after_first_colon: true
            '-peakPowerForChannel:':
                name: "getPeakPower"
            '-averagePowerForChannel:':
                name: "getAveragePower"
    AVAudioRecorder: # DONE
        properties:
            'settings':
                type: "NSDictionary<NSString, ?>"
            'channelAssignments':
                type: "NSArray<AVAudioSessionChannelDescription>"
        methods:
            '-initWithURL:settings:error:':
                name: "init"
                parameters:
                    settings:
                        type: "NSDictionary<NSString, ?>"
            '-recordAtTime:':
                trim_after_first_colon: true
            '-recordForDuration:':
                trim_after_first_colon: true
            '-recordAtTime:forDuration:':
                name: "record"
            '-peakPowerForChannel:':
                name: "getPeakPower"
            '-averagePowerForChannel:':
                name: "getAveragePower"
    AVAudioSession: # DONE
        properties:
            'availableInputs':
                type: "NSArray<AVAudioSessionPortDescription>"
            'inputDataSources':
                type: "NSArray<AVAudioSessionDataSourceDescription>"
            'outputDataSources':
                type: "NSArray<AVAudioSessionDataSourceDescription>"
        methods:
            '-setActive:.*':
                trim_after_first_colon: true
            '-setCategory:.*':
                trim_after_first_colon: true
            '-requestRecordPermission:':
                trim_after_first_colon: true
                parameters:
                    response:
                        type: "@Block VoidBooleanBlock"
            '-setMode:error:':
                trim_after_first_colon: true
            '-overrideOutputAudioPort:error:':
                trim_after_first_colon: true
            '-setPreferredInput:error:':
                trim_after_first_colon: true
            '+sharedInstance':
                return_type: "AVAudioSession"
            '-setPreferredSampleRate:error:':
                trim_after_first_colon: true
            '-setPreferredIOBufferDuration:error:':
                trim_after_first_colon: true
            '-setPreferredInputNumberOfChannels:error:':
                trim_after_first_colon: true
            '-setPreferredOutputNumberOfChannels:error:':
                trim_after_first_colon: true
            '-setInputGain:error:':
                trim_after_first_colon: true
            '-setInputDataSource:error:':
                trim_after_first_colon: true
            '-setOutputDataSource:error:':
                trim_after_first_colon: true
            '-setPreferredHardwareSampleRate:error:':
                trim_after_first_colon: true
    AVAudioSessionChannelDescription: {} # DONE
    AVAudioSessionDataSourceDescription: # DONE
        properties:
            'supportedPolarPatterns':
                type: "NSArray<NSString>"
        methods:
            '-setPreferredPolarPattern:error:':
                trim_after_first_colon: true
    AVAudioSessionPortDescription: # DONE
        properties:
            'channels':
                type: "NSArray<AVAudioSessionChannelDescription>"
            'dataSources':
                type: "NSArray<AVAudioSessionDataSourceDescription>"
        methods:
            '-setPreferredDataSource:error:':
                trim_after_first_colon: true
    AVAudioSessionRouteDescription: # DONE
        properties:
            'inputs':
                type: "NSArray<AVAudioSessionPortDescription>"
            'outputs':
                type: "NSArray<AVAudioSessionPortDescription>"
    AVCaptureAudioChannel: {} # DONE
    AVCaptureAudioDataOutput: # DONE
        methods:
            '-setSampleBufferDelegate:queue:':
                trim_after_first_colon: true
            '-recommendedAudioSettingsForAssetWriterWithOutputFileType:':
                name: "getRecommendedAudioSettings"
                return_type: "NSDictionary<NSString, ?>"
    AVCaptureConnection: # DONE
        properties:
            'inputPorts':
                type: "NSArray<AVCaptureInputPort>"
            'audioChannels':
                type: "NSArray<AVCaptureAudioChannel>"
    AVCaptureDevice: # DONE
        properties:
            'formats':
                type: "NSArray<AVCaptureDeviceFormat>"
        methods:
            '-hasMediaType:':
                trim_after_first_colon: true
            '-lockForConfiguration:':
                trim_after_first_colon: true
            '-supportsAVCaptureSessionPreset:':
                trim_after_first_colon: true
            '+devices':
                name: "getDevices"
                return_type: "NSArray<AVCaptureDevice>"
            '+devicesWithMediaType:':
                name: "getDevices"
                return_type: "NSArray<AVCaptureDevice>"
            '+defaultDeviceWithMediaType:':
                name: "getDefaultDevice"
            '+deviceWithUniqueID:':
                name: "getDevice"
            '-isFlashModeSupported:':
                trim_after_first_colon: true
            '-isTorchModeSupported:':
                trim_after_first_colon: true
            '-setTorchModeOnWithLevel:error:':
                name: "setTorchModeOn"
            '-isFocusModeSupported:':
                trim_after_first_colon: true
            '-isExposureModeSupported:':
                trim_after_first_colon: true
            '-isWhiteBalanceModeSupported:':
                trim_after_first_colon: true
            '-rampToVideoZoomFactor:withRate:':
                trim_after_first_colon: true
            '+authorizationStatusForMediaType:':
                name: "getAuthorizationStatus"
            '+requestAccessForMediaType:completionHandler:':
                trim_after_first_colon: true
    AVCaptureDeviceFormat: # DONE
        properties:
            'videoSupportedFrameRateRanges':
                type: "NSArray<AVFrameRateRange>"    
    AVCaptureDeviceInput: # DONE
        methods:
            '-initWithDevice:error:':
                name: "init"
            '+deviceInputWithDevice:error:':
                name: "create"
                return_type: "AVCaptureDeviceInput" 
    AVCaptureDeviceInputSource: {} # DONE
    AVCaptureFileOutput: # DONE
        methods:
            '-startRecordingToOutputFileURL:recordingDelegate:':
                name: "startRecording"
    AVCaptureInput: # DONE
        properties:
            'ports':
                type: "NSArray<AVCaptureInputPort>"
    AVCaptureInputPort: {} # DONE
    AVCaptureMetadataOutput: # DONE
        properties:
            'availableMetadataObjectTypes':
                type: "NSArray<NSString>"
            'metadataObjectTypes':
                type: "NSArray<NSString>"
        methods:
            '-setMetadataObjectsDelegate:queue:':
                trim_after_first_colon: true
    AVCaptureMovieFileOutput: # DONE
        properties:
            'metadata':
                type: "NSArray<AVMetadataItem>"
    AVCaptureOutput: # DONE
        properties:
            'connections':
                type: "NSArray<AVCaptureConnection>"
        methods:
            '-connectionWithMediaType:':
                name: "getConnection"
            '-transformedMetadataObjectForMetadataObject:connection:':
                name: "getTransformedMetadataObject"
            '-metadataOutputRectOfInterestForRect:':
                name: "getRectOfInterestInOutputCoordinates"
            '-rectForMetadataOutputRectOfInterest:':
                name: "getRectOfInterestInMetadataOutputCoordinates"
    AVCaptureSession: # DONE
        properties:
            'inputs':
                type: "NSArray<AVCaptureInput>"
            'outputs':
                type: "NSArray<AVCaptureOutput>"
        methods:
            '-canSetSessionPreset:':
                trim_after_first_colon: true
            '-canAddInput:':
                trim_after_first_colon: true
            '-addInput:':
                trim_after_first_colon: true
            '-removeInput:':
                trim_after_first_colon: true
            '-canAddOutput:':
                trim_after_first_colon: true
            '-addOutput:':
                trim_after_first_colon: true
            '-removeOutput:':
                trim_after_first_colon: true
    AVCaptureStillImageOutput: # DONE
        properties:
            'outputSettings':
                type: "NSDictionary<NSString, ?>"
            'availableImageDataCVPixelFormatTypes':
                type: "NSArray<?>"
        methods:
            '-captureStillImageAsynchronouslyFromConnection:completionHandler:':
                name: "captureStillImageAsynchronously"
            '+jpegStillImageNSDataRepresentation:':
                name: "getJPEGStillImageNSDataRepresentation"  
    AVCaptureVideoDataOutput: # DONE
        properties:
            'videoSettings':
                type: "NSDictionary<NSString, ?>"
            'availableVideoCVPixelFormatTypes':
                type: "NSArray<NSNumber>"
            'availableVideoCodecTypes':
                type: "NSArray<NSString>"
        methods:
            '-setSampleBufferDelegate:queue:':
                trim_after_first_colon: true
            '-recommendedVideoSettingsForAssetWriterWithOutputFileType:':
                name: "getRecommendedVideoSettings"
                return_type: "NSDictionary<NSString, ?>"
    AVCaptureVideoPreviewLayer: # DONE
        properties:
            'videoGravity':
                type: AVLayerVideoGravity
        methods:
            '-initWithSessionWithNoConnection:':
                exclude: true
            '-initWithSession:':
                name: init
            '-captureDevicePointOfInterestForPoint:':
                name: captureDevicePointOfInterest
            '-pointForCaptureDevicePointOfInterest:':
                name: getDevicePointOfInterest
            '-metadataOutputRectOfInterestForRect:':
                name: getRectOfInterestInLayerCoordinates
            '-rectForMetadataOutputRectOfInterest:':
                name: getRectOfInterestInMetadataOutputCoordinates
            '-transformedMetadataObjectForMetadataObject:':
                name: getTransformedMetadataObject
            '+layerWithSession:':
                name: create
                return_type: AVCaptureVideoPreviewLayer
    AVComposition: # DONE
        properties:
            'tracks':
                type: "NSArray<AVAssetTrack>" # AVCompositionTrack
    AVCompositionTrack: # DONE
        properties:
            'segments':
                type: "NSArray<AVAssetTrackSegment>" # AVCompositionTrackSegment
    AVCompositionTrackSegment: # DONE
        methods:
            '-initWithURL:trackID:sourceTimeRange:targetTimeRange:':
                name: "init"
            '-initWithTimeRange:':
                name: "init"
            '+compositionTrackSegmentWithURL:trackID:sourceTimeRange:targetTimeRange:':
                name: "create"
            '+compositionTrackSegmentWithTimeRange:':
                name: "create"
    AVFrameRateRange: {} # DONE
    AVMediaSelectionGroup: # DONE
        properties:
            'options':
                type: "NSArray<AVMediaSelectionOption>"
        methods:
            '-mediaSelectionOptionWithPropertyList:':
                name: "getMediaSelectionOption"
            '+playableMediaSelectionOptionsFromArray:':
                name: "getPlayableMediaSelectionOptions"
                return_type: "NSArray<AVMediaSelectionOption>"
                parameters:
                    mediaSelectionOptions:
                        type: "NSArray<AVMediaSelectionOption>"
            '+mediaSelectionOptionsFromArray:filteredAndSortedAccordingToPreferredLanguages:':
                name: "getMediaSelectionOptions"
                return_type: "NSArray<AVMediaSelectionOption>"
                parameters:
                    mediaSelectionOptions:
                        type: "NSArray<AVMediaSelectionOption>"
                    preferredLanguages:
                        type: "NSArray<NSString>"
            '+mediaSelectionOptionsFromArray:withLocale:':
                name: "getMediaSelectionOption"
                return_type: "NSArray<AVMediaSelectionOption>"
                parameters:
                    mediaSelectionOptions:
                        type: "NSArray<AVMediaSelectionOption>"
            '+mediaSelectionOptionsFromArray:withMediaCharacteristics:':
                name: "getMediaSelectionOptionsWithMediaCharacteristics"
                return_type: "NSArray<AVMediaSelectionOption>"
                parameters:
                    mediaSelectionOptions:
                        type: "NSArray<AVMediaSelectionOption>"
                    mediaCharacteristics:
                        type: "NSArray<NSString>"
            '+mediaSelectionOptionsFromArray:withoutMediaCharacteristics:':
                name: "getMediaSelectionOptionsWithoutMediaCharacteristics"
                return_type: "NSArray<AVMediaSelectionOption>"
                parameters:
                    mediaSelectionOptions:
                        type: "NSArray<AVMediaSelectionOption>"
                    mediaCharacteristics:
                        type: "NSArray<NSString>"
    AVMediaSelectionOption: # DONE
        properties:
            'mediaSubTypes':
                type: "NSArray<NSNumber>"
            'commonMetadata':
                type: "NSArray<AVMetadataItem>"
            'availableMetadataFormats':
                type: "NSArray<NSString>"
        methods:
            '-hasMediaCharacteristic:':
                trim_after_first_colon: true
            '-metadataForFormat:':
                name: "getMetadata"
                parameters:
                    format:
                        type: "NSString"
                return_type: "NSArray<AVMetadataItem>"
            '-associatedMediaSelectionOptionInMediaSelectionGroup:':
                name: "getAssociatedMediaSelectionOption"
            '-propertyList':
                property: true
            '-displayNameWithLocale:':
                name: "getDisplayName"
    AVMetadataFaceObject: {} # DONE
    AVMetadataItem: # DONE
        properties:
            'key':
                type: "NSString"
            'value':
                type: "NSObject"
            'extraAttributes':
                type: "NSDictionary<NSString, ?>"
        methods:
            '-statusOfValueForKey:error:':
                name: "getStatusOfValue"
            '-loadValuesAsynchronouslyForKeys:completionHandler:':
                name: "loadValuesAsynchronously"
                parameters:
                    keys:
                        type: "NSArray<NSString>"
            '+metadataItemsFromArray:filteredAndSortedAccordingToPreferredLanguages:':
                name: "getMetadataItems"
                return_type: "NSArray<AVMetadataItem>"
                parameters:
                    metadataItems:
                        type: "NSArray<AVMetadataItem>"
                    preferredLanguages:
                        type: "NSArray<AVMetadataItem>"
            '+metadataItemsFromArray:withLocale:':
                name: "getMetadataItems"
                return_type: "NSArray<AVMetadataItem>"
                parameters:
                    metadataItems:
                        type: "NSArray<AVMetadataItem>"
            '+metadataItemsFromArray:withKey:keySpace:':
                name: "getMetadataItems"
                return_type: "NSArray<AVMetadataItem>"
                parameters:
                    metadataItems:
                        type: "NSArray<AVMetadataItem>"
            '+metadataItemsFromArray:filteredByMetadataItemFilter:':
                name: "getMetadataItems"
                return_type: "NSArray<AVMetadataItem>"
                parameters:
                    metadataItems:
                        type: "NSArray<AVMetadataItem>"
    AVMetadataItemFilter: # DONE
        methods:
            '+metadataItemFilterForSharing':
                name: "sharedInstance"
    AVMetadataMachineReadableCodeObject: # DONE
        properties:
            'corners':
                type: "NSArray<NSDictionary<NSString, ?>>"
    AVMetadataObject: {} # DONE
    AVMutableAudioMix: # DONE
        properties:
            'inputParameters':
                type: "NSArray<AVAudioMixInputParameters>"
        methods:
            '+audioMix':
                name: "create"
    AVMutableAudioMixInputParameters: # DONE
        methods:
            '-setVolumeRampFromStartVolume:toEndVolume:timeRange:':
                name: "setVolumeRamp"
            '-setVolume:atTime:':
                trim_after_first_colon: true
            '+audioMixInputParametersWithTrack:':
                name: "create"
            '+audioMixInputParameters':
                name: "create"
    AVMutableComposition: # DONE
        properties:
            'tracks':
                type: "NSArray<AVAssetTrack>" # AVMutableCompositionTrack
        methods:
            '+composition':
                name: "create"
            '-insertTimeRange:ofAsset:atTime:error:':
                trim_after_first_colon: true
            '-insertEmptyTimeRange:':
                trim_after_first_colon: true
            '-removeTimeRange:':
                trim_after_first_colon: true
            '-scaleTimeRange:toDuration:':
                trim_after_first_colon: true
            '-addMutableTrackWithMediaType:preferredTrackID:':
                name: "addMutableTrack"
            '-removeTrack:':
                trim_after_first_colon: true
            '-mutableTrackCompatibleWithTrack:':
                name: "getCompatibleMutableTrack"
    AVMutableCompositionTrack: # DONE
        properties:
            'segments':
                type: "NSArray<AVAssetTrackSegment>" # AVCompositionTrackSegment
        methods:
            '-insertTimeRange:ofTrack:atTime:error:':
                trim_after_first_colon: true
            '-insertTimeRanges:ofTracks:atTime:error:':
                trim_after_first_colon: true
                parameters:
                    timeRanges:
                        type: "NSArray<?>" # CMTimeRange
            '-insertEmptyTimeRange:':
                trim_after_first_colon: true
            '-removeTimeRange:':
                trim_after_first_colon: true
            '-scaleTimeRange:toDuration:':
                trim_after_first_colon: true
            '-validateTrackSegments:error:':
                trim_after_first_colon: true
                parameters:
                    trackSegments:
                        type: "NSArray<AVCompositionTrackSegment>"
    AVMutableMetadataItem: # DONE
        properties:
            'key':
                type: "NSString"
            'value':
                type: "NSObject"
            'extraAttributes':
                type: "NSDictionary<NSString, ?>"
        methods:
            '+metadataItem':
                name: "create"
    AVMutableTimedMetadataGroup: # DONE
        properties:
            'items':
                type: "NSArray<AVMetadataItem>"
    AVMutableVideoComposition: # DONE
        properties:
            'instructions':
                type: "NSArray<AVVideoCompositionInstruction>"
        methods:
            '+videoComposition':
                name: "create"
            '+videoCompositionWithPropertiesOfAsset:':
                name: "create"
    AVMutableVideoCompositionInstruction: # DONE
        properties:
            'layerInstructions':
                type: "NSArray<AVVideoCompositionLayerInstruction>" # AVMutableVideoCompositionLayerInstruction
        methods:
            '+videoCompositionInstruction':
                name: "create"
    AVMutableVideoCompositionLayerInstruction: # DONE
        methods:
            '-setTransformRampFromStartTransform:toEndTransform:timeRange:':
                name: "setTransformRamp"
            '-setTransform:atTime:':
                trim_after_first_colon: true
            '-setOpacityRampFromStartOpacity:toEndOpacity:timeRange:':
                name: "setOpacityRamp"
            '-setOpacity:atTime:':
                trim_after_first_colon: true
            '-setCropRectangleRampFromStartCropRectangle:toEndCropRectangle:timeRange:':
                name: "setCropRectangleRamp"
            '-setCropRectangle:atTime:':
                trim_after_first_colon: true
            '+videoCompositionLayerInstructionWithAssetTrack:':
                name: "create"
            '+videoCompositionLayerInstruction':
                name: "create"
    AVOutputSettingsAssistant: # DONE
        properties:
            'audioSettings':
                type: "NSDictionary<NSString, ?>"
            'videoSettings':
                type: "NSDictionary<NSString, ?>"
        methods:
            '+availableOutputSettingsPresets':
                name: "getAvailableOutputSettingsPresets"
                return_type: "NSArray<NSString>"
            '+outputSettingsAssistantWithPreset:':
                name: "create"
    AVPlayer: # DONE
        methods:
            '-initWithURL:':
                name: "init"
            '-initWithPlayerItem:':
                name: "init"
            '+playerWithURL:':
                name: "create"
                return_type: "AVPlayer"
            '+playerWithPlayerItem:':
                name: "create"
                return_type: "AVPlayer"
            '-replaceCurrentItemWithPlayerItem:':
                name: "replaceCurrentItem"
            '-currentTime':
                property: true
            '-seekToDate:':
                trim_after_first_colon: true
            '-seekToDate:completionHandler:':
                trim_after_first_colon: true
            '-seekToTime.*':
                trim_after_first_colon: true
            '-setRate:time:atHostTime:':
                trim_after_first_colon: true
            '-prerollAtRate:completionHandler:':
                trim_after_first_colon: true
            '-addPeriodicTimeObserverForInterval:queue:usingBlock:':
                name: "addPeriodicTimeObserver"
            '-addBoundaryTimeObserverForTimes:queue:usingBlock:':
                name: "addBoundaryTimeObserver"
                parameters:
                    times:
                        type: "NSArray<?>" # CMTime
            '-removeTimeObserver:':
                trim_after_first_colon: true
            '-setMediaSelectionCriteria:forMediaCharacteristic:':
                trim_after_first_colon: true
            '-mediaSelectionCriteriaForMediaCharacteristic:':
                name: "getMediaSelectionCriteria"
    AVPlayerItem: # DONE
        properties:
            'tracks':
                type: "NSArray<AVPlayerItemTrack>"
            'timedMetadata':
                type: "NSArray<AVMetadataItem>"
            'automaticallyLoadedAssetKeys':
                type: "NSArray<NSString>"
            'seekableTimeRanges':
                type: "NSArray<NSValue>"
            'textStyleRules':
                type: "NSArray<AVTextStyleRule>"
            'loadedTimeRanges':
                type: "NSArray<NSValue>"
            'outputs':
                type: "NSArray<AVPlayerItemOutput>"
        methods:
            '-initWithURL:':
                name: "init"
            '-initWithAsset:':
                name: "init"
            '-initWithAsset:automaticallyLoadedAssetKeys:':
                name: "init"
                parameters:
                    automaticallyLoadedAssetKeys:
                        type: "NSArray<NSString>"
            '+playerItemWithURL:':
                name: "create"
            '+playerItemWithAsset:':
                name: "create"
            '+playerItemWithAsset:automaticallyLoadedAssetKeys:':
                name: "create"
                parameters:
                    automaticallyLoadedAssetKeys:
                        type: "NSArray<NSString>"
            '-currentTime':
                property: true
            '-seekToTime.*':
                trim_after_first_colon: true
            '-currentDate':
                property: true
            '-seekToDate.*':
                trim_after_first_colon: true
            '-stepByCount:':
                trim_after_first_colon: true
            '-selectMediaOption:inMediaSelectionGroup:':
                trim_after_first_colon: true
            '-selectMediaOptionAutomaticallyInMediaSelectionGroup:':
                name: "selectMediaOptionAutomatically"
            '-selectedMediaOptionInMediaSelectionGroup:':
                name: "getSelectedMediaOption"
            '-accessLog':
                property: true
            '-errorLog':
                property: true
            '-addOutput:':
                trim_after_first_colon: true
            '-removeOutput:':
                trim_after_first_colon: true
    AVPlayerItemAccessLog: # DONE
        properties:
            'events':
                type: "NSArray<AVPlayerItemAccessLogEvent>"
        methods:
            '-extendedLogData':
                property: true
            '-extendedLogDataStringEncoding':
                property: true
    AVPlayerItemAccessLogEvent: {} # DONE
    AVPlayerItemErrorLog: # DONE
        properties:
            'events':
                type: "NSArray<AVPlayerItemErrorLogEvent>"
        methods:
            '-extendedLogData':
                property: true
            '-extendedLogDataStringEncoding':
                property: true
    AVPlayerItemErrorLogEvent: {} # DONE
    AVPlayerItemLegibleOutput: # DONE
        methods:
            '-setDelegate:queue:':
                trim_after_first_colon: true
            '-initWithMediaSubtypesForNativeRepresentation:':
                name: "init"
                parameters:
                    subtypes:
                        type: "NSArray<NSNumber>"
    AVPlayerItemOutput: # DONE
        methods:
            '-itemTimeForHostTime:':
                name: "getItem"
            '-itemTimeForMachAbsoluteTime:':
                name: "getItem"
    AVPlayerItemTrack: {} # DONE
    AVPlayerItemVideoOutput: # DONE
        methods:
            '-initWithPixelBufferAttributes:':
                name: "init"
                parameters:
                    pixelBufferAttributes:
                        type: "NSDictionary<NSString, ?>"
            '-hasNewPixelBufferForItemTime:':
                name: "hasNewPixelBuffer"
            '-copyPixelBufferForItemTime:itemTimeForDisplay:':
                name: "copyPixelBuffer"
            '-setDelegate:queue:':
                trim_after_first_colon: true
            '-requestNotificationOfMediaDataChangeWithAdvanceInterval:':
                name: "requestNotificationOfMediaDataChange"
    AVPlayerLayer: # DONE
        properties:
            'videoGravity':
                type: AVLayerVideoGravity
        methods:
            '+playerLayerWithPlayer:':
                name: create
    AVPlayerMediaSelectionCriteria: # DONE
        properties:
            'preferredLanguages':
                type: "NSArray<NSString>"
            'preferredMediaCharacteristics':
                type: "NSArray<NSString>"
        methods:
            '-initWithPreferredLanguages:preferredMediaCharacteristics:':
                name: init
                parameters:
                    preferredLanguages:
                        type: "NSArray<NSString>"
                    preferredMediaCharacteristics:
                        type: "NSArray<NSString>"
    AVQueuePlayer: # DONE
        methods:
            '-initWithItems:':
                name: "init"
                parameters:
                    items:
                        type: "NSArray<AVPlayerItem>"
            '-items':
                property: true
                return_type: "NSArray<AVPlayerItem>"
            '-canInsertItem:afterItem:':
                trim_after_first_colon: true
            '-insertItem:afterItem:':
                trim_after_first_colon: true
            '-removeItem:':
                trim_after_first_colon: true
            '+queuePlayerWithItems:':
                name: "create"
                return_type: "AVQueuePlayer"
                parameters:
                    items:
                        type: "NSArray<AVPlayerItem>"
    AVSpeechSynthesisVoice: # DONE
        methods:
            '+speechVoices':
                name: "getSpeechVoices"
                return_type: "NSArray<AVSpeechSynthesisVoice>"
            '+currentLanguageCode':
                name: "getCurrentLanguageCode"
            '+voiceWithLanguage:':
                name: "create"
    AVSpeechSynthesizer: # DONE
        methods:
            '-speakUtterance:':
                name: "addSpeakUtterance"
            '-stopSpeakingAtBoundary:':
                name: "stopSpeaking"
            '-pauseSpeakingAtBoundary:':
                name: "pauseSpeaking"
    AVSpeechUtterance: # DONE
        methods:
            '-initWithString:':
                name: "init"
            '+speechUtteranceWithString:':
                name: "create"
    AVSynchronizedLayer: # DONE
        methods:
            '+synchronizedLayerWithPlayerItem:':
                name: "create"
    AVTextStyleRule: # DONE
        properties:
            'textMarkupAttributes':
                type: "NSDictionary<NSString, ?>"
        methods:
            '-init.*':
                name: "init"
                parameters:
                    textMarkupAttributes:
                        type: "NSDictionary<NSString, ?>"
            '+propertyListForTextStyleRules:':
                name: "createPropertyList"
                parameters:
                    textStyleRules:
                        type: "NSArray<AVTextStyleRule>"
            '+textStyleRulesFromPropertyList:':
                name: "createTextStyleRulesArray"
                return_type: "NSArray<AVTextStyleRule>"
            '+textStyleRuleWithTextMarkupAttributes:':
                name: "create"
                parameters:
                    textMarkupAttributes:
                        type: "NSDictionary<NSString, ?>"
            '+textStyleRuleWithTextMarkupAttributes:textSelector:':
                name: "create"
                parameters:
                    textMarkupAttributes:
                        type: "NSDictionary<NSString, ?>"
    AVTimedMetadataGroup: # DONE
        properties:
            'items':
                type: "NSArray<AVMetadataItem>"
        methods:
            '-initWithItems:timeRange:':
                name: "init"
                parameters:
                    items:
                        type: "NSArray<AVMetadataItem>"
    AVURLAsset: # DONE
        methods:
            '-initWithURL:options:':
                name: "init"
                parameters:
                    options:
                        type: "NSDictionary<NSString, ?>"
            '+audiovisualTypes':
                property: true
                return_type: "NSArray<NSString>"
            '+audiovisualMIMETypes':
                property: true
                return_type: "NSArray<NSString>"
            '+isPlayableExtendedMIMEType:':
                trim_after_first_colon: true
            '+URLAssetWithURL:options:':
                name: "create"
                parameters:
                    options:
                        type: "NSDictionary<NSString, ?>"
            '-compatibleTrackForCompositionTrack:':
                name: "getCompatibleTrack"
    AVVideoComposition: # DONE
        properties:
            'instructions':
                type: "NSArray<AVVideoCompositionInstruction>"
        methods:
            '+videoCompositionWithPropertiesOfAsset:':
                name: "create"
            '-isValidForAsset:timeRange:validationDelegate:':
                name: "isValid"
    AVVideoCompositionCoreAnimationTool: # DONE
        methods:
            '+videoCompositionCoreAnimationToolWithAdditionalLayer:asTrackID:':
                name: "create"
            '+videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayer:inLayer:':
                name: "create"
            '+videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayers:inLayer:':
                name: "create"    
    AVVideoCompositionInstruction: # DONE
        properties:
            'layerInstructions':
                type: "NSArray<AVVideoCompositionLayerInstruction>"
            'requiredSourceTrackIDs':
                type: "NSArray<NSString>"

    AVVideoCompositionLayerInstruction: # DONE
        methods:
            '-getTransformRampForTime:startTransform:endTransform:timeRange:':
                name: "getTransformRamp"
            '-getOpacityRampForTime:startOpacity:endOpacity:timeRange:':
                name: "getOpacityRamp"
            '-getCropRectangleRampForTime:startCropRectangle:endCropRectangle:timeRange:':
                name: "getCropRectangleRamp" 
    AVVideoCompositionRenderContext: {} # DONE
    
    # Structs
    AVPixelAspectRatio: {}
    AVEdgeWidths: {}
    AVCaptureWhiteBalanceGains: {}
    AVCaptureWhiteBalanceChromaticityValues: {}
    AVCaptureWhiteBalanceTemperatureAndTintValues: {}

protocols:
    AVAssetResourceLoaderDelegate: # DONE
        methods:
            '-resourceLoader:shouldWaitForLoadingOfRequestedResource:':
                name: "shouldWait"
            '-resourceLoader:didCancelLoadingRequest:':
                name: "didCancel"  
    AVAsynchronousKeyValueLoading: # DONE
        methods: 
            '-loadValuesAsynchronouslyForKeys:completionHandler:':
                name: "loadValuesAsynchronously"
                parameters:
                    keys:
                        type: "NSArray<NSString>"
            '-statusOfValueForKey:error:':
                name: "getStatusOfValue"
    AVAudioPlayerDelegate: # DONE
        methods:
            '-audioPlayerDidFinishPlaying:successfully:':
                name: "didFinishPlaying"
            '-audioPlayerDecodeErrorDidOccur:error:':
                name: "decodeErrorDidOccur"
            '-audioPlayerBeginInterruption:':
                name: "beginInterruption"
            '-audioPlayerEndInterruption:withOptions:':
                name: "endInterruptionWithOptions"
            '-audioPlayerEndInterruption:withFlags:':
                name: "endInterruptionWithFlags"
            '-audioPlayerEndInterruption:':
                name: "endInterruption"
    AVAudioRecorderDelegate: # DONE
        methods:
            '-audioRecorderDidFinishRecording:successfully:':
                name: "didFinishRecording"
            '-audioRecorderEncodeErrorDidOccur:error:':
                name: "encodeErrorDidOccur"
            '-audioRecorderBeginInterruption:':
                name: "beginInterruption"
            '-audioRecorderEndInterruption:withOptions:':
                name: "endInterruptionWithOptions"
            '-audioRecorderEndInterruption:withFlags:':
                name: "endInterruptionWithFlags"
            '-audioRecorderEndInterruption:':
                name: "endInterruption"
    AVAudioSessionDelegate: # DONE
        methods:
            '-endInterruptionWithFlags:':
                name: "endInterruption"
                parameters:
                    flags:
                        type: "AVAudioSessionInterruptionFlag"
            '-inputIsAvailableChanged:':
                name: "inputAvailabilityChanged"
    AVCaptureAudioDataOutputSampleBufferDelegate: # DONE
        methods:
            '-captureOutput:didOutputSampleBuffer:fromConnection:':
                name: "didOutputSampleBuffer"   
    AVCaptureFileOutputRecordingDelegate: # DONE
        methods:
            '-captureOutput:didStartRecordingToOutputFileAtURL:fromConnections:':
                name: "didStartRecording"
                parameters:
                    connections:
                        type: "NSArray<AVCaptureConnection>"
            '-captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error:':
                name: "didFinishRecording"
                parameters:
                    connections:
                        type: "NSArray<AVCaptureConnection>"
    AVCaptureMetadataOutputObjectsDelegate: # DONE
        methods:
            '-captureOutput:didOutputMetadataObjects:fromConnection:':
                name: "didOutputMetadataObjects"
                parameters:
                    metadataObjects:
                        type: "NSArray<AVMetadataObject>"
    AVCaptureVideoDataOutputSampleBufferDelegate: # DONE
        methods:
            '-captureOutput:didOutputSampleBuffer:fromConnection:':
                name: "didOutputSampleBuffer"
            '-captureOutput:didDropSampleBuffer:fromConnection:':
                name: "didDropSampleBuffer"
    AVPlayerItemLegibleOutputPushDelegate: # DONE
        methods:
            '-legibleOutput:didOutputAttributedStrings:nativeSampleBuffers:forItemTime:':
                name: "didOutputAttributedStrings"
                parameters:
                    strings:
                        type: "NSArray<NSAttributedString>"
                    nativeSamples:
                        type: "NSArray<?>" # CMSampleBuffer
    AVPlayerItemOutputPullDelegate: # DONE
        methods:
            '-outputMediaDataWillChange:':
                name: "mediaDataWillChange"
            '-outputSequenceWasFlushed:':
                name: "sequenceWasFlushed"
    AVPlayerItemOutputPushDelegate: # DONE
        methods:
            '-outputSequenceWasFlushed:':
                name: "wasFlushed"
    AVSpeechSynthesizerDelegate: # DONE
        methods:
            '-speechSynthesizer:didStartSpeechUtterance:':
                name: "didStartSpeechUtterance"
            '-speechSynthesizer:didFinishSpeechUtterance:':
                name: "didFinishSpeechUtterance"
            '-speechSynthesizer:didPauseSpeechUtterance:':
                name: "didPauseSpeechUtterance"
            '-speechSynthesizer:didContinueSpeechUtterance:':
                name: "didContinueSpeechUtterance"
            '-speechSynthesizer:didCancelSpeechUtterance:':
                name: "didCancelSpeechUtterance"
            '-speechSynthesizer:willSpeakRangeOfSpeechString:utterance:':
                name: "willSpeak"
    AVVideoCompositionValidationHandling: # DONE
        methods:
            '-videoComposition:shouldContinueValidatingAfterFindingInvalidValueForKey:':
                name: "shouldContinueValidatingAfterFindingInvalidValue"
            '-videoComposition:shouldContinueValidatingAfterFindingEmptyTimeRange:':
                name: "shouldContinueValidatingAfterFindingEmptyTimeRange"
            '-videoComposition:shouldContinueValidatingAfterFindingInvalidTimeRangeInInstruction:':
                name: "shouldContinueValidatingAfterFindingInvalidTimeRange"
            '-videoComposition:shouldContinueValidatingAfterFindingInvalidTrackIDInInstruction:layerInstruction:asset:':
                name: "shouldContinueValidatingAfterFindingInvalidTrackID"
    AVVideoCompositing: # DONE
        properties:
            'sourcePixelBufferAttributes':
                type: "NSDictionary<NSString, ?>"
            'requiredPixelBufferAttributesForRenderContext':
                type: "NSDictionary<NSString, ?>"
        methods:
            '-renderContextChanged:':
                trim_after_first_colon: true
            '-startVideoCompositionRequest:':
                trim_after_first_colon: true

functions:
    # Make sure we don't miss any functions if new ones are introduced in a later version
    (AV.*):
        class: AVFoundation
        name: "Function__#{g[0]}"

values:
    # AVLayer
    AVLayerVideoGravity(.*):
        class: AVLayerVideoGravity
        name: '#{g[0]}Value'
        type: NSString
        visibility: protected

    AVFormat(.*)Key:
        class: AVFoundation
        name: "AVFormat#{g[0]}Key"

    AVSampleRate(.*)Key:
        class: AVFoundation
        name: "AVSampleRate#{g[0]}Key"

    AV(NumberOfChannels)Key:
        class: AVFoundation
        name: "#{g[0]}Key"

    AVLinearPCM(.*)Key:
        class: AVFoundation
        name: "AVLinearPCM#{g[0]}Key"
    AVLinearPCM(.*):
        class: AVFoundation
        name: "AVLinearPCM#{g[0]}"
        
    AVEncoder(.*)Key:
        class: AVFoundation
        name: "AVEncoder#{g[0]}Key"
        
    AVSampleRateConverter(.*)Key:
        class: AVFoundation
        name: "AVSampleRateConverter#{g[0]}Key"
    AVSampleRateConverterAlgorithm_(.*):
        class: AVFoundation
        name: "AVSampleRateConverterAlgorithm_#{g[0]}"
        
    AVChannelLayout(.*)Key:
        class: AVFoundation
        name: "AVChannelLayout#{g[0]}Key"
        
    AVAudioBitRateStrategy_(.*):
        class: AVFoundation
        name: "AVAudioBitRateStrategy#{g[0]}"
        
    AVAudioSession(.*)Notification:
        class: AVFoundation
        name: "AVAudioSession#{g[0]}Notification"
    AVAudioSession(.*)Key:
        class: AVFoundation
        name: "AVAudioSession#{g[0]}Key"
    AVAudioSessionCategory(.*):
        class: AVFoundation
        name: "AVAudioSessionCategory#{g[0]}"
    AVAudioSessionMode(.*):
        class: AVFoundation
        name: "AVAudioSessionMode#{g[0]}"
    AVAudioSessionPort(.*):
        class: AVFoundation
        name: "AVAudioSessionPort#{g[0]}"
    AVAudioSessionLocation(.*):
        class: AVFoundation
        name: "AVAudioSessionLocation#{g[0]}"
    AVAudioSessionOrientation(.*):
        class: AVFoundation
        name: "AVAudioSessionOrientation#{g[0]}"
    AVAudioSessionPolarPattern(.*):
        class: AVFoundation
        name: "AVAudioSessionPolarPattern#{g[0]}"
        
    AVCoreAnimation(BeginTimeAtZero):
        class: AVFoundation
        name: "AVCoreAnimation#{g[0]}"
        
    AVURLAsset(.*)Key:
        class: AVFoundation
        name: "AVURLAsset#{g[0]}Key"
        
    AVAssetExportPreset(.*):
        class: AVFoundation
        name: "AVAssetExportPreset#{g[0]}"
    AVAssetImageGenerator(.*):
        class: AVFoundation
        name: "AVAssetImageGenerator#{g[0]}"
    AVTrackAssociationType(.*):
        class: AVFoundation
        name: "AVTrackAssociationType#{g[0]}"
        
    AVAudioTimePitchAlgorithm(.*):
        class: AVFoundation
        name: "AVAudioTimePitchAlgorithm#{g[0]}"
        
    AVCaptureDevice(.*)Notification:
        class: AVFoundation
        name: "AVCaptureDevice#{g[0]}Notification"
    AVCapture(MaxAvailableTorchLevel):
        class: AVFoundation
        name: "AVCapture#{g[0]}"
        
    AVCaptureSession(.*)Notification:
        class: AVFoundation
        name: "AVCaptureSession#{g[0]}Notification"
    AVCaptureSession(.*)Key:
        class: AVFoundation
        name: "AVCaptureSession#{g[0]}Key"
    AVCaptureSessionPreset(.*):
        class: AVFoundation
        name: "AVCaptureSessionPreset#{g[0]}"
    AVCapture(.*)Notification:
        class: AVFoundation
        name: "AVCapture#{g[0]}Notification"
        
    AVFoundation(ErrorDomain):
        class: AVFoundation
        name: "#{g[0]}"
        
    AVError(.*)Key:
        class: AVFoundation
        name: "AVError#{g[0]}Key"
        
    AVMediaType(.*):
        class: AVFoundation
        name: "AVMediaType#{g[0]}"
        
    AVMediaCharacteristic(.*):
        class: AVFoundation
        name: "AVMediaCharacteristic#{g[0]}"
        
    AVFileType(.*):
        class: AVFoundation
        name: "AVFileType#{g[0]}"
        
    AVMetadata(.*):
        class: AVFoundation
        name: "AVMetadata#{g[0]}"
        
    AVOutputSettingsPreset(.*):
        class: AVFoundation
        name: "AVOutputSettingsPreset#{g[0]}"
        
    AVPlayerItem(.*)Notification:
        class: AVFoundation
        name: "AVPlayerItem#{g[0]}Notification"
    AVPlayerItem(.*)Key:
        class: AVFoundation
        name: "AVPlayerItem#{g[0]}Key"
        
    AVPlayerItemLegibleOutput(.*):
        class: AVFoundation
        name: "AVPlayerItemLegibleOutput#{g[0]}"
        
    AVSpeechUtterance(.*):
        class: AVFoundation
        name: "AVSpeechUtterance#{g[0]}"
        
    AVVideo(.*)Key:
        class: AVFoundation
        name: "AVVideo#{g[0]}Key"
    AVVideoCodec(.*):
        class: AVFoundation
        name: "AVVideoCodec#{g[0]}"
    AVVideoScalingMode(.*):
        class: AVFoundation
        name: "AVVideoScalingMode#{g[0]}"
    AVVideoProfileLevelH264(.*):
        class: AVFoundation
        name: "AVVideoProfileLevelH264#{g[0]}"
    AVVideoH264EntropyMode(.*):
        class: AVFoundation
        name: "AVVideoH264EntropyMode#{g[0]}"
    

    # Make sure we don't miss any values if new ones are introduced in a later version
    (AV.*):
        class: AVFoundation
        name: "Value__#{g[0]}"

constants:
    # Make sure we don't miss any constants if new ones are introduced in a later version
    (AV.*):
        class: AVFoundation
        name: "Constant__#{g[0]}"
